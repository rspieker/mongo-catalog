name: Recipe

on:
    push:
    schedule:
        # - cron: '0 7 * * 0/3'
        - cron: '0 */2 * * *'
    workflow_dispatch:

jobs:
    setup:
        runs-on: ubuntu-latest

        steps:
            - uses: actions/checkout@v4

            - name: Node.js
              uses: actions/setup-node@v4
              with:
                  node-version: 20.x
                  cache: 'npm'

            - name: install
              run: npm install

            - name: Update Mongo Versions
              run: npm run update:mongo-versions

            - name: Update Catalog Queries
              run: npm run update:catalog-queries

            - name: Upload initial state
              uses: actions/upload-artifact@v4
              with:
                  name: mongo-state
                  path: ./automation/
                  retention-days: 1

    workload:
        runs-on: ubuntu-latest
        needs: setup

        outputs:
            work: ${{ steps.capture.outputs.captured }}

        steps:
            - uses: actions/checkout@v4

            - name: Download state
              uses: actions/download-artifact@v4
              with:
                  name: mongo-state
                  path: ./automation/

            - name: Node.js
              uses: actions/setup-node@v4
              with:
                  node-version: 20.x
                  cache: 'npm'

            - name: install
              run: npm install

            - name: Determine Workload
              id: capture
              run: |
                  WORKLOAD_OUTPUT=$(npm run --silent update:workload)
                  # Extract just the versions array from the JSON output
                  VERSIONS=$(echo "$WORKLOAD_OUTPUT" | jq -c '.versions')
                  echo "captured=$VERSIONS" >> "$GITHUB_OUTPUT"

            - name: Upload updated state
              uses: actions/upload-artifact@v4
              with:
                  name: mongo-state
                  path: ./automation/
                  retention-days: 1
                  overwrite: true

    collect-versions:
        runs-on: ubuntu-latest
        needs: workload
        continue-on-error: true

        strategy:
            fail-fast: false
            matrix:
                version: ${{ fromJSON(needs.workload.outputs.work )}}

        env:
            MONGO_VERSION: ${{ matrix.version }}

        steps:
            - uses: actions/checkout@v4

            - name: Download state
              uses: actions/download-artifact@v4
              with:
                  name: mongo-state
                  path: ./automation/

            - name: Create staging directory
              run: mkdir -p /tmp/mongo-catalog-changes

            - name: Node.js
              uses: actions/setup-node@v4
              with:
                  node-version: 20.x
                  cache: 'npm'

            - name: Get Docker tag
              id: docker
              run: |
                  # we could've just used continue-on-error, but then we
                  # couldn't justify to laugh at the joke they really are
                  trap 'echo "failure_message=docker-tag-resolution-failed" >> $GITHUB_OUTPUT; exit 0' ERR
                  VERSION="${{ matrix.version }}"
                  MAJOR=$(echo "$VERSION" | cut -d. -f1)
                  DOCKER_TAG=$(jq -r '.name' "./automation/collect/v${MAJOR}/${VERSION}/plan.json")
                  echo "tag=$DOCKER_TAG" >> "$GITHUB_OUTPUT"

            - name: Start MongoDB
              id: mongodb
              run: |
                  # Propagate previous failure if present
                  if [ "${{ steps.docker.outputs.failure_message }}" != "" ]; then
                    echo "failure_message=${{ steps.docker.outputs.failure_message }}" >> $GITHUB_OUTPUT
                    exit 0
                  fi
                  
                  # we could've just used continue-on-error, but then we
                  # couldn't justify to laugh at the joke they really are
                  trap 'echo "failure_message=mongodb-start-failed" >> $GITHUB_OUTPUT; exit 0' ERR
                  VERSION="${{ matrix.version }}"
                  DOCKER_TAG="${{ steps.docker.outputs.tag }}"

                  # Start MongoDB container in background
                  docker run -d \
                    --name mongodb-$VERSION \
                    -p 27017:27017 \
                    --health-cmd="mongo --eval 'quit(0)' || mongosh --eval 'quit(0)' || exit 1" \
                    --health-interval=10s \
                    --health-timeout=5s \
                    --health-retries=5 \
                    mongo:$DOCKER_TAG

                  # Wait for healthy
                  echo "Waiting for MongoDB to be healthy..."
                  for i in {1..60}; do
                    HEALTH=$(docker inspect --format='{{.State.Health.Status}}' mongodb-$VERSION 2>/dev/null || echo "starting")
                    if [ "$HEALTH" = "healthy" ]; then
                      echo "MongoDB is healthy!"
                      break
                    fi
                    echo "Status: $HEALTH (attempt $i/60)"
                    sleep 2
                  done

                  if [ "$HEALTH" != "healthy" ]; then
                    echo "MongoDB failed to become healthy"
                    docker logs mongodb-$VERSION
                    exit 1
                  fi

            - name: Install dependencies
              id: install
              run: |
                  # Propagate previous failure if present
                  if [ "${{ steps.mongodb.outputs.failure_message }}" != "" ]; then
                    echo "failure_message=${{ steps.mongodb.outputs.failure_message }}" >> $GITHUB_OUTPUT
                    exit 0
                  fi
                  
                  # we could've just used continue-on-error, but then we
                  # couldn't justify to laugh at the joke they really are
                  trap 'echo "failure_message=npm-install-failed" >> $GITHUB_OUTPUT; exit 0' ERR
                  npm install

            - name: Run collection
              id: collect
              run: |
                  # Propagate previous failure if present
                  if [ "${{ steps.install.outputs.failure_message }}" != "" ]; then
                    echo "failure_message=${{ steps.install.outputs.failure_message }}" >> $GITHUB_OUTPUT
                    exit 0
                  fi
                  
                  # we could've just used continue-on-error, but then we
                  # couldn't justify to laugh at the joke they really are
                  trap 'echo "failure_message=catalog-execution-failed" >> $GITHUB_OUTPUT; exit 0' ERR
                  npm run update:mongo-collect

            - name: Gate
              if: always()
              run: |
                  # Check all failure_message outputs
                  FAILED=""

                  if [ "${{ steps.docker.outputs.failure_message }}" != "" ]; then
                    FAILED="${{ steps.docker.outputs.failure_message }}"
                  elif [ "${{ steps.mongodb.outputs.failure_message }}" != "" ]; then
                    FAILED="${{ steps.mongodb.outputs.failure_message }}"
                  elif [ "${{ steps.install.outputs.failure_message }}" != "" ]; then
                    FAILED="${{ steps.install.outputs.failure_message }}"
                  elif [ "${{ steps.collect.outputs.failure_message }}" != "" ]; then
                    FAILED="${{ steps.collect.outputs.failure_message }}"
                  fi

                  if [ -n "$FAILED" ]; then
                    VERSION="${{ matrix.version }}"
                    MAJOR=$(echo "$VERSION" | cut -d. -f1)
                    META_FILE="./automation/collect/v${MAJOR}/${VERSION}/meta.json"

                    echo "Marking $VERSION as skipped due to: $FAILED"

                    NOW=$(date -u +"%Y-%m-%dT%H:%M:%S.%3NZ")
                    jq --arg reason "$FAILED" --arg date "$NOW" '
                      .skip = true |
                      .history = (.history // []) + [{
                        "type": "SKIP",
                        "date": $date,
                        "actions": [{
                          "type": "SKIP",
                          "reason": $reason,
                          "date": $date
                        }]
                      }]
                    ' "$META_FILE" > "$META_FILE.tmp" && mv "$META_FILE.tmp" "$META_FILE"

                    mkdir -p "/tmp/mongo-catalog-changes/${VERSION}"
                    cp "$META_FILE" "/tmp/mongo-catalog-changes/${VERSION}/meta.json"
                  fi

                  exit 0

            - name: Cleanup MongoDB
              if: always()
              run: |
                  VERSION="${{ matrix.version }}"
                  docker stop mongodb-$VERSION 2>/dev/null || true
                  docker rm mongodb-$VERSION 2>/dev/null || true

            - name: Upload results
              if: always()
              uses: actions/upload-artifact@v4
              with:
                  name: results-${{ matrix.version }}
                  path: /tmp/mongo-catalog-changes
                  retention-days: 1

    commit-results:
        runs-on: ubuntu-latest
        needs: collect-versions
        if: always()

        steps:
            - uses: actions/checkout@v4

            - name: Download base state
              uses: actions/download-artifact@v4
              with:
                  name: mongo-state
                  path: ./automation/

            - name: Download results
              uses: actions/download-artifact@v4
              with:
                  path: /tmp/results/
                  pattern: 'results-*'
                  merge-multiple: false

            - name: Merge version-specific results
              run: |
                  for artifact_dir in /tmp/results/results-*/; do
                    if [ -d "$artifact_dir" ]; then
                      # artifact_dir contains something like: 5.0.32/
                      for version_dir in "$artifact_dir"*/; do
                        if [ -d "$version_dir" ]; then
                          version_name=$(basename "$version_dir")
                          major_version="v${version_name%%.*}"

                          echo "Copying $version_name to automation/collect/$major_version/"
                          mkdir -p "./automation/collect/$major_version"
                          cp -r "$version_dir" "./automation/collect/$major_version/"
                        fi
                      done
                    fi
                  done

            - name: Unify Results
              run: npm run update:unify

            - name: Commit results
              run: |
                  git config user.name "GitHub Actions Recipe Bot"
                  git config user.email "<>"
                  git add ./automation/
                  git diff --cached --quiet || (git commit -m "Update catalog results $(date +"%Y-%m-%dT%H:%M:%S%z")" && git push origin main)
